### Выводы по заданию четыре
После компиляции командой <gcc -c practic3_4_file1.c practic3_4_file2.c main.c> появились файлы main.o, practic3_4_file1.o, practic3_4_file2.o
Флаг -c позволяет получить бинарный код, но это все еще не исполняемый файл и его нельзя запустить.
После применения утилиты nm к файлу practic3_4_file1.o у меня появилась информация о global_var, printf, print_from_file1, static_var.
Согласно выводу, static_var - локальная переменная, остальные глобальные. global_var - глобальная переменная в секции DATA.
После применения nm к practic3_4_file2.o на экране появилась та же самая информация, кроме флага для переменной static_var.
Он сменился с d на U. Флаг U означает, что переменная не определена. Также printf_from_file1 поменялась на printf_from_file2, что логично.
После применения nm к main.o видим, что main находится в секции TEXT, а global_var, printf, print_from_file1, printf_from_file2 неопределены.
После попытки скомпилировать программу командой <gcc practic3_4_file1.c practic3_4_file2.c main.c> я получила ошибку компиляции из - за повторного определения global var, а также из - за попытки вывести в функции print_from_file2() переменной static_var.
Чтобы испраивть ошибку, я убрала строку с переопределением переменной global var.
Также я убрала строку extern int static_var; Также я убрада из функции print_from_file2 строку для вывода static_var; 
Теперь компиляция проходит успешно.
Теперь снова будем компилировать по очереди файлы с флагом -c и применять к полученным файлам утилиту nm.
Для файла practic3_4_file1.o ничего не изменилось.
Для файла practic3_4_file2.o исчезла информация о static_var, так как теперь мы не пытаемся ее объявить в этом файле и она доступна только в practic3_4_file1. Также флаг global_var поменялся с D на U
Для файла main.o ничего не изменилось.
С помощью objdump можно посмотреть, в какой секции лежат те или иные переменные.
Для файла practic3_4_file1.o: static_var и global_var - '.data', print_from_file1 - '.text'
Для файла practic3_4_file2.o: printfrom_file2 - '.text', global_var и printf - *UND*. Это означает, что в коде присутствует ссылка на символ, который не определен в этом файле но должен быть определен в другом объектном файле или библиотеке
Для файла main.o: main - '.text', global_var, printf, print_from_file1, print_from_file2 - *UND*.
С помощью команды <strings main> я проверила файл main и не нашла там строк из printf().
Я выполнила команду <objdump -x main>. Она показала архитектуру процессора, формат файла, полный заголовок программы, динамический раздел со всеми используемыми адресами памяти, информацию об используемых разделах и расширенную таблицу символов
Далее я выполнила статическое связывание командой <gcc -static practic3_4_file1.c practic3_4_file2.c main.c>, а затем запустила команду <objdump -x main>. Судя по выводу утилиты, программа начнет работать с адреса 0x00000000000010c0 (это было сказано в поле "Начальный адрес"). программа использует такие секции памяти, как '.text', '.bss', '.fini_array', '.init_array', *UND*, '.data', '.rodata', '.fini', '.init' и другие, что указано в SYMBOL TABLE. Единственная автоматически загружаемая библиотека - libc.so.6 (указана в поле NEEDED)
Дополнительный вопрос: global_var есть в '.data', так как это глобальная переменная, проинициализированная значением, а такие переменные хранятся в '.data'. static_var является статической переменной за счет ключевого слова static, а значит видна она будет только из файла practic3_4_file1.c, а значит нет необходимости добавлять ее в таблицу символов, так как мы заранее знаем, что кроме файла practic3_4_file1.c к этой переменной обращаться никто не будет, т.е. у нас есть возможность уменьшить таблицу символов.


## Конспект по 3 семинару
double sec;
(int)sec; - явное приведение типов
Елси целое число делится на целое, то будет возвращена целая часть от деления
Если одно из чисел дробное, то и результат будет дробным (как результат вычислений в классической математике)

## Typedef
Конструкция используется для сокращения кода при использовании агрегатных типов. Пример синтаксиса есть ниже

```c
typedef enum {
    Gasoline, 
    Diesel, 
    Electric
} EngineType;

EngineType someEngine = Electric;
EngineType someEngine = 2; // можно и так, и так
```

```c
typedef enum {
    Gasoline = 3, 
    Diesel, 
    Electric
} EngineType;
EngineType someEngine = 5; //отсчет теперь идет не с нуля, а с трех, т.е Diesel = 4, Electric = 5
```


